# Introduction aux applications Web

Avant de commencer la programmation, nous passerons en revue certains principes de dÃ©veloppement Web 
en examinant un exemple d'application sur [https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp).

L'application n'existe que pour dÃ©montrer certains concepts de base du cours et n'est en aucun cas un exemple de comment une application Web 
moderne doit Ãªtre crÃ©Ã©e. Au contraire, il dÃ©montre certaines anciennes techniques de dÃ©veloppement Web, 
qui pourraient mÃªme Ãªtre considÃ©rÃ©es comme de mauvaises pratiques de nos jours.

Ouvrez l'[exemple d'application](https://studies.cs.helsinki.fi/exampleapp) dans votre navigateur. Parfois, cela prend un certain temps.

**La 1Ã¨re rÃ¨gle du dÃ©veloppement Web**: gardez toujours la Developer Console ouverte sur votre navigateur Web. 
Sur macOS, ouvrez la console en appuyant simultanÃ©ment sur *F12 ou option-cmd-i*. Sous Windows ou Linux, 
ouvrez la console en appuyant simultanÃ©ment sur *F12 ou ctrl-shift-i*. La console peut Ã©galement Ãªtre ouverte via le menu contextuel.

N'oubliez pas de toujours garder la Developer Console ouverte lors du dÃ©veloppement d'applications Web.

La console ressemble Ã  ceci :

![alt premier image](/images/courses/1e.png)

Assurez-vous que l'onglet RÃ©seau est ouvert et cochez l'option *DÃ©sactiver le cache* comme indiquÃ©. *Conserver le journal* peut Ã©galement Ãªtre utile : 
il enregistre les journaux imprimÃ©s par l'application lorsque la page est rechargÃ©e.

**NB** : L'onglet le plus important est l'onglet Console. Cependant, dans cette introduction, nous utiliserons un peu l'onglet RÃ©seau.

## HTTP GET

Le serveur et le navigateur Web communiquent entre eux Ã  l'aide du protocole [HTTP](https://developer.mozilla.org/fr/docs/Web/HTTP). 
L'onglet RÃ©seau montre comment le navigateur et le serveur communiquent.

Lorsque vous rechargez la page (appuyez sur la touche F5 ou sur le symbole â†» de votre navigateur), 
la console indique que deux Ã©vÃ©nements se sont produits :

* Le navigateur a rÃ©cupÃ©rÃ© le contenu de la page studies.cs.helsinki.fi/exampleapp du serveur
* Et a tÃ©lÃ©chargÃ© l'image kuva.png

![alt deuxieme image](/images/courses/2e.png)

Sur un petit Ã©cran, vous devrez peut-Ãªtre Ã©largir la fenÃªtre de la console pour les voir.

Cliquer sur le premier Ã©vÃ©nement rÃ©vÃ¨le plus d'informations sur ce qui se passe :

![alt troisieme image](/images/courses/3e.png)

La partie supÃ©rieure, GÃ©nÃ©ral, montre que le navigateur a fait une requÃªte Ã  l'adresse 
[https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp) 
(bien que l'adresse ait lÃ©gÃ¨rement changÃ© depuis que cette photo a Ã©tÃ© prise) 
en utilisant la mÃ©thode GET, et que la requÃªte a rÃ©ussi, car la rÃ©ponse du serveur avait le code de statut 200.

La requÃªte et la rÃ©ponse du serveur ont plusieurs **en-tÃªtes** :

![alt quatrieme image](/images/courses/4e.png)

Les en-tÃªtes de rÃ©ponse en haut nous indiquent par ex. la taille de la rÃ©ponse en octets et l'heure exacte de la rÃ©ponse. 
Un en-tÃªte important **Content-Type** nous indique que la rÃ©ponse est un fichier texte en **utf-8-format**, dont le contenu a Ã©tÃ© formatÃ© avec HTML. 
De cette faÃ§on, le navigateur sait que la rÃ©ponse est une page **HTML** normale et la restitue au navigateur "comme une page Web".

L'onglet RÃ©ponse affiche les donnÃ©es de rÃ©ponse, une page HTML normale. La section body dÃ©termine la structure de la page rendue Ã  l'Ã©cran :

![alt cinquieme image](/images/courses/5e.png)

La page contient un Ã©lÃ©ment *div*, qui Ã  son tour contient un titre, un lien vers la page notes et une balise img et affiche le nombre de notes crÃ©Ã©es.

En raison de la balise *img*, le navigateur effectue une seconde requÃªte *HTTP* pour rÃ©cupÃ©rer l'image *kuva.png* du serveur. Les dÃ©tails de la demande sont les suivants :

![alt sixieme image](/images/courses/6e.png)

La requÃªte a Ã©tÃ© faite Ã  l'adresse [https://studies.cs.helsinki.fi/exampleapp/kuva.png](https://studies.cs.helsinki.fi/exampleapp/kuva.png) 
et son type est HTTP GET. Les en-tÃªtes de rÃ©ponse nous indiquent que la taille de la rÃ©ponse est de 89350 octets et que son *Content-type* est *image/png*, 
c'est donc une image png. Le navigateur utilise ces informations pour restituer correctement l'image Ã  l'Ã©cran.

La chaÃ®ne d'Ã©vÃ©nements provoquÃ©e par l'ouverture de la page [https://studies.cs.helsinki.fi/exampleapp](https://studies.cs.helsinki.fi/exampleapp )
sur un navigateur se prÃ©sente comme suit diagramme de sÃ©quence:

![alt septieme image](/images/courses/7e.png)

Tout d'abord, le navigateur envoie une requÃªte HTTP GET au serveur pour rÃ©cupÃ©rer le code HTML de la page. 
La balise img dans le code HTML invite le navigateur Ã  rÃ©cupÃ©rer l'image kuva.png. Le navigateur affiche la page HTML et l'image Ã  l'Ã©cran.

MÃªme s'il est difficile de s'en apercevoir, la page HTML commence Ã  s'afficher avant que l'image n'ait Ã©tÃ© extraite du serveur.

## Applications Web traditionnelles

La page d'accueil de l'exemple d'application fonctionne comme une *application Web traditionnelle*. 
En entrant dans la page, le navigateur va chercher sur le serveur le document HTML dÃ©taillant la structure et le contenu textuel de la page.

Le serveur a formÃ© ce document d'une maniÃ¨re ou d'une autre. 
Le document peut Ãªtre un fichier texte statique enregistrÃ© dans le rÃ©pertoire du serveur. 
Le serveur peut Ã©galement former les documents HTML de maniÃ¨re *dynamique* selon le code de l'application, 
en utilisant par exemple les donnÃ©es d'une base de donnÃ©es. Le code HTML de l'exemple d'application a Ã©tÃ© formÃ© dynamiquement, 
car il contient des informations sur le nombre de notes crÃ©Ã©es.

Le code HTML de la page d'accueil est le suivant :

```js
const getFrontPageHtml = (noteCount) => {
  return(`
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Full stack example app</h1>
          <p>number of notes created ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
`)
} 

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})
```

Vous n'avez pas encore besoin de comprendre le code.

Le contenu de la page HTML a Ã©tÃ© enregistrÃ© en tant que chaÃ®ne de modÃ¨le, ou une chaÃ®ne qui permet d'Ã©valuer, 
par exemple, des variables au milieu de celle-ci. La partie dynamique de la page d'accueil, 
le nombre de notes enregistrÃ©es (dans le code *noteCount*), est remplacÃ©e par le nombre actuel de 
notes (dans le code *notes.length*) dans la chaÃ®ne de modÃ¨le.

Ã‰crire du HTML au milieu du code n'est bien sÃ»r pas intelligent, mais pour les programmeurs PHP de la vieille Ã©cole, c'Ã©tait une pratique normale.

Dans les applications Web traditionnelles, le navigateur est "stupide". 
Il rÃ©cupÃ¨re uniquement les donnÃ©es HTML du serveur et toute la logique d'application se trouve sur le serveur. 
Un serveur peut Ãªtre crÃ©Ã© en utilisant Java Spring, Python Flask ou avec Ruby on Rails pour ne citer que quelques exemples.

L'exemple utilise **Express** de Node.js. Ce cours utilisera Node.js et Express pour crÃ©er des serveurs Web.

## Execution de la logique d'application dans le navigateur

Gardez la Developer Console ouverte. Videz la console en cliquant sur le symbole ğŸš« ou en tapant clear() dans la console. 
DÃ©sormais, lorsque vous accÃ©dez Ã  la page *notes*, le navigateur effectue 4 requÃªtes HTTP :

![alt huitieme image](/images/courses/8e.png)

Toutes les demandes ont des types *diffÃ©rents*. 
Le type de la premiÃ¨re requÃªte est *document*. C'est le code HTML de la page, et il se prÃ©sente comme suit :

![alt neuvieme image](/images/courses/9e.png)

Lorsque l'on compare la page affichÃ©e sur le navigateur et le code HTML renvoyÃ© par le serveur, 
on remarque que le code ne contient pas la liste des notes. 
La section head du code HTML contient un script-tag, qui amÃ¨ne le navigateur Ã  rÃ©cupÃ©rer un fichier JavaScript appelÃ© *main.js*.

Le code JavaScript ressemble Ã  ceci :

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementById('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()
```

Les dÃ©tails du code ne sont pas importants pour le moment, mais du code a Ã©tÃ© inclus pour pimenter les images et le texte. 
Nous commencerons correctement Ã  coder dans la **partie 1**. L'exemple de code de cette partie n'est en fait pas du tout pertinent 
pour les techniques de codage de ce cours.

> Certains pourraient se demander pourquoi xhttp-object est utilisÃ© Ã  la place du fetch moderne. 
Cela est dÃ» au fait de ne pas encore du tout vouloir entrer dans les promesses, et le code ayant un rÃ´le secondaire dans cette partie. 
Nous reviendrons sur les moyens modernes de faire des requÃªtes au serveur dans la partie 2.

ImmÃ©diatement aprÃ¨s avoir rÃ©cupÃ©rÃ© la balise *script*, le navigateur commence Ã  exÃ©cuter le code.

Les deux derniÃ¨res lignes indiquent au navigateur d'effectuer une requÃªte HTTP GET Ã  l'adresse du serveur */data.json* :

```js
xhttp.open('GET', '/data.json', true)
xhttp.send()
```

Il s'agit de la requÃªte la plus basse affichÃ©e dans l'onglet RÃ©seau.

Nous pouvons essayer d'aller Ã  l'adresse [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json) 
directement depuis le navigateur :

![alt dixieme image](/images/courses/10e.png)

On y retrouve les notes en JSON "raw data". Par dÃ©faut, les navigateurs basÃ©s sur Chromium ne sont pas trÃ¨s bons pour afficher les donnÃ©es JSON. 
Des plugins peuvent Ãªtre utilisÃ©s pour gÃ©rer le formatage. Installez, par exemple, [JSON Viewer](https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh) 
sur Chrome, et rechargez la page. Les donnÃ©es sont maintenant bien formatÃ©es :

![alt onzieme image](/images/courses/11e.png)

Ainsi, le code JavaScript de la page de notes ci-dessus tÃ©lÃ©charge les donnÃ©es JSON contenant les notes et forme une liste Ã  puces Ã  partir du contenu de la note :

Cela se fait par le code suivant :

```js
const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)
```

Le code crÃ©e d'abord une liste non ordonnÃ©e avec une balise ul-tag...

```js
var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')
```

... puis ajoute une balise *li* pour chaque note. Seul le champ *contenu* de chaque note devient le contenu de la balise li. 
Les horodatages trouvÃ©s dans les donnÃ©es brutes ne sont utilisÃ©s pour rien ici.

![alt douzieme image](/images/courses/12e.png)

En cliquant sur le petit triangle au dÃ©but de la ligne, vous pouvez dÃ©velopper le texte sur la console.

![alt treizieme image](/images/courses/13e.png)

Cette sortie sur la console est causÃ©e par la commande *console.log* dans le code :

```js

const data = JSON.parse(this.responseText)
console.log(data)

```

Ainsi, aprÃ¨s avoir reÃ§u les donnÃ©es du serveur, le code les imprime sur la console.

L'onglet Console et la commande *console.log* vous deviendront trÃ¨s familiers pendant le cours.

## Gestionnaires d'evenements et fonctions Callback

La structure de ce code est un peu bizarre :

```js
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // code that takes care of the server response
}

xhttp.open('GET', '/data.json', true)
xhttp.send()

```

La requÃªte au serveur est envoyÃ©e sur la derniÃ¨re ligne, mais le code pour gÃ©rer la rÃ©ponse se trouve plus haut. Que se passe-t-il?

```js
xhttp.onreadystatechange = function () {
```

Sur cette ligne, un *gestionnaire d'Ã©vÃ©nements* pour l'Ã©vÃ©nement *onreadystatechange* est dÃ©fini pour l'objet *xhttp* effectuant la requÃªte. 
Lorsque l'Ã©tat de l'objet change, le navigateur appelle la fonction de gestionnaire d'Ã©vÃ©nements. 
Le code de la fonction vÃ©rifie que *readyState* est Ã©gal Ã  4 (ce qui dÃ©crit la situation L'opÃ©ration est *terminÃ©e*) 
et que le code d'Ã©tat HTTP de la rÃ©ponse est 200.

```js
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // code that takes care of the server response
  }
}
```

Le mÃ©canisme d'appel des gestionnaires d'Ã©vÃ©nements est trÃ¨s courant en JavaScript. 
Les fonctions de gestionnaire d'Ã©vÃ©nements sont appelÃ©es fonctions **callback**. 
Le code d'application n'appelle pas les fonctions lui-mÃªme, mais l'environnement d'exÃ©cution - le navigateur, 
appelle la fonction Ã  un moment appropriÃ©, lorsque l'*Ã©vÃ©nement* s'est produit.

## Document Object Model ou DOM

Nous pouvons considÃ©rer les pages HTML comme des arborescences implicites.

```html
html
  head
    link
    script
  body
    div
      h1
      div
        ul
          li
          li
          li
      form
        input
        input
```

La mÃªme structure arborescente peut Ãªtre vue sur l'onglet *Ã‰lÃ©ments* de la console.

![alt quatorzieme image](/images/courses/14e.png)

Le fonctionnement du navigateur est basÃ© sur l'idÃ©e de reprÃ©senter les Ã©lÃ©ments HTML sous forme d'arborescence.

Document Object Model, ou *DOM*, est une interface de programmation d'application (API) qui permet la modification 
par programmation des arborescences d'Ã©lÃ©ments correspondant aux pages Web.

Le code JavaScript introduit dans le chapitre prÃ©cÃ©dent utilisait l'API DOM pour ajouter une liste de notes Ã  la page.

Le code suivant crÃ©e un nouveau nÅ“ud pour la variable *ul* et y ajoute des nÅ“uds enfants :

```js
var ul = document.createElement('ul')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})
```

Enfin, la branche d'arborescence de la variable ul est connectÃ©e Ã  sa place dans l'arborescence HTML de toute la page :

```js
document.getElementById('notes').appendChild(ul)
```

## Manipulation du l'objet document depuis la console

Le nÅ“ud le plus haut de l'arborescence DOM d'un document HTML est appelÃ© l'objet *document*. 
Nous pouvons effectuer diverses opÃ©rations sur une page Web Ã  l'aide de l'API DOM. 
Vous pouvez accÃ©der Ã  l'objet *document* en tapant *document* dans l'onglet Console :

![alt quinzieme image](/images/courses/15e.png)

Ajoutons une nouvelle note Ã  la page depuis la console.

Tout d'abord, nous allons obtenir la liste des notes de la page. La liste se trouve dans le premier Ã©lÃ©ment ul de la page :

```js
list = document.getElementsByTagName('ul')[0]
```

CrÃ©ez ensuite un nouvel Ã©lÃ©ment li et ajoutez-y du contenu textuel :

```js
newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'
```

Et ajoutez le nouvel Ã©lÃ©ment li Ã  la liste :

```js
list.appendChild(newElement)
```

![alt seizieme image](/images/courses/16e.png)

MÃªme si la page est mise Ã  jour sur votre navigateur, les modifications ne sont pas permanentes. 
Si la page est rechargÃ©e, la nouvelle note disparaÃ®tra, car les modifications n'ont pas Ã©tÃ© transmises au serveur. 
Le code JavaScript que le navigateur rÃ©cupÃ¨re crÃ©era toujours la liste des notes basÃ©es sur les donnÃ©es JSON 
Ã  partir de l'adresse [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json).

## CSS

CSS
L'Ã©lÃ©ment *head* du code HTML de la page Notes contient une balise *link*, 
qui dÃ©termine que le navigateur doit rÃ©cupÃ©rer une feuille de style *CSS* Ã  partir de l'adresse *main.css*.

Les feuilles de style en cascade, ou CSS, sont un langage de feuille de style utilisÃ© pour dÃ©terminer l'apparence des pages Web.

Le fichier CSS rÃ©cupÃ©rÃ© ressemble Ã  ceci :

```css
.container {
  padding: 10px;
  border: 1px solid; 
}

.notes {
  color: blue;
}
```

Le fichier dÃ©finit *deux sÃ©lecteurs* de classe. Ceux-ci sont utilisÃ©s pour sÃ©lectionner certaines parties de la page et pour dÃ©finir des rÃ¨gles de style pour les styliser.

Une dÃ©finition de sÃ©lecteur de classe commence toujours par un point et contient le nom de la classe.

Les classes sont des attributs, qui peuvent Ãªtre ajoutÃ©s aux Ã©lÃ©ments HTML.

Les attributs CSS peuvent Ãªtre examinÃ©s dans l'onglet *Ã©lÃ©ments* de la console :

![alt dix septieme image](/images/courses/17e.png)

L'Ã©lÃ©ment *div* le plus externe a la classe *container*. L'Ã©lÃ©ment *ul* contenant la liste des notes a la classe notes.

La rÃ¨gle CSS dÃ©finit que les Ã©lÃ©ments avec la classe *container* seront dÃ©limitÃ©s par une bordure large d'un pixel. 
Il dÃ©finit Ã©galement 10 pixels de padding sur l'Ã©lÃ©ment. Cela ajoute un espace vide entre le contenu de l'Ã©lÃ©ment et la bordure.

La deuxiÃ¨me rÃ¨gle CSS dÃ©finit la couleur du texte des notes en bleu.

Les Ã©lÃ©ments HTML peuvent Ã©galement avoir d'autres attributs en dehors des classes. 
L'Ã©lÃ©ment div contenant les notes a un attribut id. Le code JavaScript utilise l'identifiant pour trouver l'Ã©lÃ©ment.

L'onglet Ã‰lÃ©ments de la console peut Ãªtre utilisÃ© pour changer les styles des Ã©lÃ©ments.

![alt dix huitieme image](/images/courses/18e.png)

Les modifications apportÃ©es sur la console ne seront pas permanentes. Si vous souhaitez apporter des modifications durables, 
elles doivent Ãªtre enregistrÃ©es dans la feuille de style CSS sur le serveur.

## Chargement d'une page contenant JavaScript - revision

Passons en revue ce qui se passe lorsque la page [ https://studies.cs.helsinki.fi/exampleapp/notes]( https://studies.cs.helsinki.fi/exampleapp/notes) 
est ouverte sur le navigateur.

![alt dix neuvieme image](/images/courses/19e.png)

- Le navigateur va chercher le code HTML dÃ©finissant le contenu et la structure de la page sur le serveur Ã  l'aide d'une requÃªte HTTP GET.
- Les liens dans le code HTML amÃ¨nent le navigateur Ã  rÃ©cupÃ©rer Ã©galement la feuille de style CSS main.css...
- ...et un fichier de code JavaScript main.js
- Le navigateur exÃ©cute le code JavaScript. Le code fait une requÃªte HTTP GET Ã  l'adresse 
[https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json), qui renvoie les notes sous forme de donnÃ©es JSON.
- Lorsque les donnÃ©es ont Ã©tÃ© rÃ©cupÃ©rÃ©es, le navigateur exÃ©cute un gestionnaire d'Ã©vÃ©nements, qui affiche les notes sur la page Ã  l'aide de l'API DOM.

## Formulaires et HTTP POST

Examinons ensuite comment l'ajout d'une nouvelle note est effectuÃ©.

La page Notes contient un form-element.

![alt image 20](/images/courses/20e.png)

Lorsque le bouton du formulaire est cliquÃ©, le navigateur enverra l'entrÃ©e de l'utilisateur au serveur. 
Ouvrons l'onglet RÃ©seau et voyons Ã  quoi ressemble l'envoi du formulaire :

![alt image 21](/images/courses/21e.png)

Ã‰tonnamment, la soumission du formulaire provoque pas moins de cinq requÃªtes HTTP. 
Le premier est l'Ã©vÃ©nement de soumission de formulaire. Zoomons dessus :

![alt image 22](/images/courses/22e.png)

Il s'agit d'une requÃªte HTTP POST Ã  l'adresse du serveur new_note. Le serveur rÃ©pond avec le code d'Ã©tat HTTP 302. 
Il s'agit d'une URL redirect, avec laquelle le serveur demande au navigateur de faire une nouvelle requÃªte HTTP GET 
Ã  l'adresse dÃ©finie dans Emplacement de l'en-tÃªte - l'adresse notes.

Ainsi, le navigateur recharge la page Notes. Le rechargement provoque trois requÃªtes HTTP supplÃ©mentaires : 
la rÃ©cupÃ©ration de la feuille de style (main.css), du code JavaScript (main.js) et des donnÃ©es brutes des notes (data.json).

L'onglet rÃ©seau affiche Ã©galement les donnÃ©es soumises avec le formulaire :

![alt image 23](/images/courses/23e.png)

La balise Form a les attributs *action* et *method*, qui dÃ©finissent que la soumission du formulaire 
se fait sous la forme d'une requÃªte HTTP POST Ã  â€‹â€‹l'adresse *new_note*.

Le code sur le serveur responsable de la requÃªte POST est assez simple (NB : ce code est sur le serveur, 
et non sur le code JavaScript rÃ©cupÃ©rÃ© par le navigateur) :

![alt image 24](/images/courses/24e.png)


```js
app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})
```

Les donnÃ©es sont envoyÃ©es en tant que corps de la requÃªte POST.

Le serveur peut accÃ©der aux donnÃ©es en accÃ©dant au champ *req.body* de l'objet de requÃªte *req*.

Le serveur crÃ©e un nouvel objet note et l'ajoute Ã  un tableau appelÃ© notes.

```js

notes.push({
  content: req.body.note,
  date: new Date(),
})

```

Les objets Note ont deux champs : *contenu* contenant le contenu rÃ©el de la note et *date* contenant la date et l'heure de crÃ©ation de la note.

Le serveur n'enregistre pas les nouvelles notes dans une base de donnÃ©es, 
de sorte que les nouvelles notes disparaissent lorsque le serveur est redÃ©marrÃ©.

## AJAX

La page Notes de l'application suit un style de dÃ©veloppement Web du dÃ©but des annÃ©es 90 et utilise "Ajax". 
En tant que tel, il est au sommet de la vague de la technologie Web du dÃ©but des annÃ©es 2000.

AJAX (JavaScript et XML asynchrones) est un terme introduit en fÃ©vrier 2005 suite aux progrÃ¨s de la technologie des navigateurs 
pour dÃ©crire une nouvelle approche rÃ©volutionnaire qui permettait de rÃ©cupÃ©rer du contenu sur des pages Web Ã  l'aide 
de JavaScript inclus dans le code HTML, sans qu'il soit nÃ©cessaire de restituer la page.

Avant l'Ã¨re AJAX, toutes les pages Web fonctionnaient comme les applications Web traditionnelles que nous avons vues prÃ©cÃ©demment dans ce chapitre. 
Toutes les donnÃ©es affichÃ©es sur la page ont Ã©tÃ© rÃ©cupÃ©rÃ©es avec le code HTML gÃ©nÃ©rÃ© par le serveur.

La page Notes utilise AJAX pour rÃ©cupÃ©rer les donnÃ©es des notes. 
La soumission du formulaire utilise toujours le mÃ©canisme traditionnel de soumission de formulaires Web.

Les URL des applications reflÃ¨tent les temps anciens et insouciants. 
Les donnÃ©es JSON sont extraites de l'URL [https://studies.cs.helsinki.fi/exampleapp/data.json](https://studies.cs.helsinki.fi/exampleapp/data.json) 
et les nouvelles notes sont envoyÃ©es Ã  l'URL [https://studies.cs.helsinki.fi/exampleapp/new_note](https://studies.cs.helsinki.fi/exampleapp/new_note). 
De nos jours, de telles URL ne seraient pas considÃ©rÃ©es comme acceptables, car elles ne respectent pas les conventions 
gÃ©nÃ©ralement reconnues des API RESTful, que nous examinerons plus en dÃ©tail dans la **partie 3**

La chose appelÃ©e AJAX est maintenant si banale qu'elle est prise pour acquise. 
Le terme est tombÃ© dans l'oubli, et la nouvelle gÃ©nÃ©ration n'en a mÃªme pas entendu parler.

## Application Ã  page unique

Dans notre exemple d'application, la page d'accueil fonctionne comme une page Web traditionnelle : 
toute la logique se trouve sur le serveur et le navigateur affiche uniquement le code HTML conformÃ©ment aux instructions.

La page Notes donne une partie de la responsabilitÃ©, gÃ©nÃ©rant le code HTML pour les notes existantes, au navigateur. 
Le navigateur s'attaque Ã  cette tÃ¢che en exÃ©cutant le code JavaScript qu'il a rÃ©cupÃ©rÃ© sur le serveur. 
Le code rÃ©cupÃ¨re les notes du serveur sous forme de donnÃ©es JSON et ajoute des Ã©lÃ©ments HTML pour afficher les notes sur la page Ã  l'aide de DOM-API.

Ces derniÃ¨res annÃ©es, le style application Ã  page unique en anglais SPA (single page application) de crÃ©ation d'applications Web a Ã©mergÃ©. 
Les sites Web de style SPA ne rÃ©cupÃ¨rent pas toutes leurs pages sÃ©parÃ©ment du serveur comme le fait notre exemple d'application, 
mais ne comprennent qu'une seule page HTML extraite du serveur, dont le contenu est manipulÃ© avec JavaScript qui s'exÃ©cute dans le navigateur.

La page Notes de notre application ressemble un peu aux applications de style SPA, mais elle n'en est pas encore lÃ . 
MÃªme si la logique de rendu des notes est exÃ©cutÃ©e sur le navigateur, la page utilise toujours la mÃ©thode traditionnelle d'ajout de nouvelles notes. 
Les donnÃ©es sont envoyÃ©es au serveur avec la soumission du formulaire, et le serveur demande au navigateur de recharger la page Notes avec une redirection.

Une version SPA de notre exemple d'application peut Ãªtre trouvÃ©e sur [https://studies.cs.helsinki.fi/exampleapp/spa](https://studies.cs.helsinki.fi/exampleapp/spa). 
Ã€ premiÃ¨re vue, l'application ressemble exactement Ã  la prÃ©cÃ©dente. 
Le code HTML est presque identique, mais le fichier JavaScript est diffÃ©rent (spa.js) et il y a un petit changement dans la faÃ§on dont la balise form est dÃ©finie :

![alt image 25](/images/courses/25e.png)

Le formulaire n'a pas d'attributs *action* ou *method* pour dÃ©finir comment et oÃ¹ envoyer les donnÃ©es d'entrÃ©e.

Ouvrez l'onglet *RÃ©seau* et videz-le. Lorsque vous crÃ©ez maintenant une nouvelle note, 
vous remarquerez que le navigateur n'envoie qu'une seule requÃªte au serveur.

![alt image 26](/images/courses/26e.png)

La requÃªte POST Ã  â€‹â€‹l'adresse *new_note_spa* contient la nouvelle note sous forme de donnÃ©es JSON contenant Ã  la fois le contenu 
de la note (*contenu*) et l'horodatage (*jour*) :

```js
{
  content: "single page app does not reload the whole page",
  date: "2019-05-25T15:15:59.905Z"
}

```

L'en-tÃªte Content-Type de la requÃªte indique au serveur que les donnÃ©es incluses sont reprÃ©sentÃ©es au format JSON.

![alt image 27](/images/courses/27e.png)

Sans cet en-tÃªte, le serveur ne saurait pas analyser correctement les donnÃ©es.

Le serveur rÃ©pond avec le code d'Ã©tat *201 crÃ©Ã©*. Cette fois, le serveur ne demande pas de redirection, 
le navigateur reste sur la mÃªme page et n'envoie plus de requÃªtes HTTP.

La version SPA de l'application n'envoie pas les donnÃ©es de formulaire de maniÃ¨re traditionnelle, 
mais utilise Ã  la place le code JavaScript qu'elle a extrait du serveur. 
Nous allons examiner un peu ce code, mÃªme si en comprendre tous les dÃ©tails n'est pas encore important.

```js
var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}
```

La commande *document.getElementById('notes_form')* indique au code de rÃ©cupÃ©rer l'Ã©lÃ©ment 
de formulaire Ã  partir de la page et d'enregistrer un gestionnaire d'Ã©vÃ©nements pour gÃ©rer l'Ã©vÃ¨nement de soumission du formulaire. 
Le gestionnaire d'Ã©vÃ©nements appelle immÃ©diatement la mÃ©thode *e.preventDefault()* pour empÃªcher la gestion par dÃ©faut de la soumission de formulaire. 
La mÃ©thode par dÃ©faut enverrait les donnÃ©es au serveur et provoquerait une nouvelle requÃªte GET, ce que nous ne voulons pas.

Ensuite, le gestionnaire d'Ã©vÃ©nements crÃ©e une nouvelle note, l'ajoute Ã  la liste des notes avec la commande *notes.push(note)*, 
restitue la liste des notes sur la page et envoie la nouvelle note au serveur.

Le code d'envoi de la note au serveur est le suivant :

```js

var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader(
    'Content-type', 'application/json'
  )
  xhttpForPost.send(JSON.stringify(note))
}

```

Le code dÃ©termine que les donnÃ©es doivent Ãªtre envoyÃ©es avec une requÃªte HTTP POST et que le type de donnÃ©es doit Ãªtre JSON. 
Le type de donnÃ©es est dÃ©terminÃ© avec un en-tÃªte Content-type. Ensuite, les donnÃ©es sont envoyÃ©es sous forme de chaÃ®ne JSON.

## Bibliotheques JavaScript

L'exemple d'application est rÃ©alisÃ© avec ce qu'on appelle vanilla JavaScript, en utilisant uniquement 
l'API DOM et JavaScript pour manipuler la structure des pages.

Au lieu d'utiliser uniquement JavaScript et l'API DOM, diffÃ©rentes bibliothÃ¨ques contenant 
des outils plus faciles Ã  utiliser par rapport Ã  l'API DOM sont souvent utilisÃ©es pour manipuler les pages. 
L'une de ces bibliothÃ¨ques est la trÃ¨s populaire jQuery.

jQuery a Ã©tÃ© dÃ©veloppÃ© Ã  l'Ã©poque oÃ¹ les applications Web suivaient principalement le style traditionnel du serveur gÃ©nÃ©rant des pages HTML, 
dont la fonctionnalitÃ© Ã©tait amÃ©liorÃ©e du cÃ´tÃ© du navigateur Ã  l'aide de JavaScript Ã©crit avec jQuery. 
L'une des raisons du succÃ¨s de jQuery Ã©tait sa soi-disant compatibilitÃ© entre navigateurs. 
La bibliothÃ¨que fonctionnait quel que soit le navigateur ou la sociÃ©tÃ© qui l'avait crÃ©Ã©e, il n'y avait donc pas besoin de 
solutions spÃ©cifiques au navigateur. De nos jours, l'utilisation de jQuery n'est plus aussi justifiÃ©e compte tenu de l'avancement de JavaScript, 
et les navigateurs les plus populaires supportent gÃ©nÃ©ralement bien les fonctionnalitÃ©s de base.

L'essor de l'application Ã  page unique a apportÃ© plusieurs mÃ©thodes de dÃ©veloppement Web plus "modernes" que jQuery. 
Le favori de la premiÃ¨re vague de dÃ©veloppeurs Ã©tait BackboneJS. AprÃ¨s son lancement en 2012, 
Google AngularJS est rapidement devenu presque la norme de facto du dÃ©veloppement Web moderne.

Cependant, la popularitÃ© d'Angular a chutÃ© en octobre 2014 aprÃ¨s que l'Ã©quipe d'Angular a annoncÃ© que le support de la version 1 prendra fin, 
et Angular 2 ne sera pas rÃ©trocompatible avec la premiÃ¨re version. Angular 2 et 
les versions plus rÃ©centes n'ont pas Ã©tÃ© trop chaleureusement accueillies.

Actuellement, l'outil le plus populaire pour implÃ©menter la logique cÃ´tÃ© navigateur des applications Web est la bibliothÃ¨que React de Facebook. 
Au cours de ce cours, nous nous familiariserons avec React et la bibliothÃ¨que Redux, qui sont frÃ©quemment utilisÃ©es ensemble.

Le statut de React semble fort, mais le monde de JavaScript est en constante Ã©volution. Par exemple, rÃ©cemment, un nouveau venu - VueJS - a suscitÃ© un certain intÃ©rÃªt.

##  Developpement Web Full Stack

Que signifie le nom du cours, *DÃ©veloppement Web Full Stack ?* Le full stack est un mot Ã  la mode dont tout le monde parle, 
alors que personne ne sait vraiment ce que cela signifie. Ou du moins, il n'y a pas de dÃ©finition convenue pour le terme.

Pratiquement toutes les applications Web ont (au moins) deux "couches": le navigateur, Ã©tant plus proche de l'utilisateur final, 
est la couche supÃ©rieure et le serveur la couche infÃ©rieure. Il y a souvent aussi une couche de base de donnÃ©es sous le serveur. 
On peut donc penser Ã  l'architecture d'une application web comme une sorte de pile de couches.

Souvent, on parle aussi du frontend et du backend. Le navigateur est l'interface, et 
JavaScript qui s'exÃ©cute sur le navigateur est le code de l'interface. Le serveur, quant Ã  lui, est le backend.

Dans le cadre de ce cours, le dÃ©veloppement web full stack signifie que nous nous concentrons sur toutes les parties de l'application : 
le frontend, le backend et la base de donnÃ©es. Parfois, le logiciel sur le serveur et son systÃ¨me d'exploitation sont considÃ©rÃ©s comme faisant 
partie de la pile, mais nous n'entrerons pas dans ceux-ci.

Nous allons coder le backend avec JavaScript, en utilisant l'environnement d'exÃ©cution Node.js. 
L'utilisation du mÃªme langage de programmation sur plusieurs couches de la pile donne au dÃ©veloppement Web de la pile complÃ¨te 
une toute nouvelle dimension. Cependant, il n'est pas obligatoire pour le dÃ©veloppement Web de la pile complÃ¨te d'utiliser 
le mÃªme langage de programmation (JavaScript) pour toutes les couches de la pile.

Auparavant, il Ã©tait plus courant pour les dÃ©veloppeurs de se spÃ©cialiser dans une couche de la pile, par exemple le backend. 
Les technologies sur le backend et le frontend Ã©taient assez diffÃ©rentes. Avec la tendance Full stack, 
il est devenu courant pour les dÃ©veloppeurs de maÃ®triser toutes les couches de l'application et de la base de donnÃ©es. 
Souvent, les dÃ©veloppeurs full stack doivent Ã©galement avoir suffisamment de compÃ©tences en configuration et en administration 
pour faire fonctionner leur application, par exemple dans le cloud.

## Fatigue JavaScript

Le dÃ©veloppement Web complet est un dÃ©fi Ã  bien des Ã©gards. Les choses se passent dans de nombreux endroits Ã  la fois, 
et le dÃ©bogage est un peu plus difficile qu'avec les applications de bureau classiques. 
JavaScript ne fonctionne pas toujours comme prÃ©vu (par rapport Ã  de nombreux autres langages), 
et le fonctionnement asynchrone de ses environnements d'exÃ©cution entraÃ®ne toutes sortes de dÃ©fis. 
Communiquer sur le web nÃ©cessite la connaissance du protocole HTTP. Il faut Ã©galement gÃ©rer les bases de donnÃ©es et 
l'administration et la configuration des serveurs. Il serait Ã©galement bon de connaÃ®tre suffisamment de CSS pour 
rendre les applications au moins quelque peu prÃ©sentables.

Le monde de JavaScript se dÃ©veloppe rapidement, ce qui apporte son lot de dÃ©fis. 
Les outils, les bibliothÃ¨ques et le langage lui-mÃªme sont en constante Ã©volution. 
Certains commencent Ã  en avoir assez du changement constant et ont inventÃ© un terme pour cela : **fatigue JavaScript**.

Vous souffrirez vous-mÃªme de la fatigue JavaScript pendant ce cours. 
Heureusement pour nous, il existe plusieurs faÃ§ons de lisser la courbe d'apprentissage, et 
nous pouvons commencer par le codage au lieu de la configuration. Nous ne pouvons pas complÃ¨tement Ã©viter la configuration, 
mais nous pouvons joyeusement aller de l'avant dans les prochaines semaines tout en Ã©vitant le pire des enfers de configuration.